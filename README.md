
## 功能介绍

1.拖拽组件库进入组件树，生成节点树

2.在节点树进行编辑，对当前节点右侧props节点面板进行编辑，实时在中间画布生效


## 技术方案

1.数据管理，数据流转，对整个树形结构构造链式结构，保证数据的单项流转，数据共存于顶层树  通过顶层树分发至子节点，每次数据结构的变更自动存至顶层树。

2.沙箱隔离画布和编辑器，无论编辑器有何种错误无法对外层编辑器造成影响

3.技术优化，所有的性能集中在树形结构的diff 所有的优化项围绕着如何减少树形结构的diff，优化树形结构拖拽编辑的速度

4.整个编辑器所用到的组件库比较多，整个打包文件略大，当前采用优化点 nginx服务端压缩   减少webpack代码检查   后续可采用优化点，把编辑器和画布分开打包，

5.后续可提升技术点  采用云构建  用户可自定义增加引入npm各类组件   

## 技术前景和使用

对非技术人员可快速创建少代码界面，减少技术成本，学习成本略低


 // "monaco-editor": "^0.33.0",
 // "monaco-editor-webpack-plugin": "^1.9.1",
 // "react-monaco-editor": "^0.48.0",

  <!-- jest-dom -->


两个定时器，本想实现相同的功能：每十秒触发一次定时器。

但是实际上，setTimeout在10ms后才加入js执行队列，排队等待。所以每两次定时器触发的时间间隔可能 > 10ms。

setInterval每10s就向js执行队列添加一个setInterval事件等待执行。前面的setInterval事件可能被它之前的事件阻塞，导致执行晚了几拍。那么没两次定时时间触发的时间间隔可能 <10ms 。

<!-- js事件循环机制 web worker -->
沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在Node.js端可以采用`vm`模块，而对于浏览器，则需要结合`with`关键字和`window.Proxy`对象来实现浏览器端的沙箱。以下为简易的实现：

